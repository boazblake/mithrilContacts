'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Licensed under MIT. See LICENCE for full licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var provideAliases = require('../../helpers/provide-fantasy-land-aliases');
var defer = require('../../helpers/defer');
var Deferred = require('../future/_deferred');
var TaskExecution = require('./_task-execution');

var noop = function noop() {};

/*~ stability: experimental */

var Task = function () {
  /*~
   * stability: experimental
   * type: |
   *   forall value, reason, resources:
   *     new (
   *       ({ resolve: (value) => Void, reject: (reason) => Void, cancel: () => Void }) => resources,
   *       (resources) => Void,
   *       (resources) => Void
   *     ) => Task value reason resources
   */
  function Task(computation, onCancel, cleanup) {
    _classCallCheck(this, Task);

    this._computation = computation;
    this._onCancel = onCancel || noop;
    this._cleanup = cleanup || noop;
  }

  /*~
   * stability: experimental
   * type: |
   *   forall e, v1, v2, r:
   *     (Task e v1 r).((v1) => Task e v2 r) => Task e v2 r
   */


  _createClass(Task, [{
    key: 'chain',
    value: function chain(transformation) {
      var _this = this;

      return new Task(function (resolver) {
        var execution = _this.run();
        execution.listen({
          onCancelled: resolver.cancel,
          onRejected: resolver.reject,
          onResolved: function onResolved(value) {
            transformation(value).run().listen({
              onCancelled: resolver.cancel,
              onRejected: resolver.reject,
              onResolved: resolver.resolve
            });
          }
        });
        return execution;
      }, function (execution) {
        return execution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e, v1, v2, r:
     *     (Task e v1 r).((v1) => v2) => Task e v2 r
     */

  }, {
    key: 'map',
    value: function map(transformation) {
      var _this2 = this;

      return new Task(function (resolver) {
        var execution = _this2.run();
        execution.listen({
          onCancelled: resolver.cancel,
          onRejected: resolver.reject,
          onResolved: function onResolved(value) {
            return resolver.resolve(transformation(value));
          }
        });
        return execution;
      }, function (execution) {
        return execution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e1, e2, v, r:
     *     (Task e1 v r).((e1) => e2) => Task e2 v r
     */

  }, {
    key: 'mapRejected',
    value: function mapRejected(transformation) {
      var _this3 = this;

      return new Task(function (resolver) {
        var execution = _this3.run();
        execution.listen({
          onCancelled: resolver.cancel,
          onRejected: function onRejected(reason) {
            return resolver.reject(transformation(reason));
          },
          onResolved: resolver.resolve
        });
        return execution;
      }, function (execution) {
        return execution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e, v1, v2, r:
     *     (Task e ((v1) => v2) r).(Task e v1 r) => Task e v2 r
     */

  }, {
    key: 'apply',
    value: function apply(task) {
      return this.chain(function (f) {
        return task.map(f);
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e1, e2, v1, v2, r:
     *     (Task e1 v1 r).((e1) => e2, (v1) => v2) => Task e2 v2 r
     */

  }, {
    key: 'bimap',
    value: function bimap(rejectionTransformation, successTransformation) {
      var _this4 = this;

      return new Task(function (resolver) {
        var execution = _this4.run();
        execution.listen({
          onCancelled: resolver.cancel,
          onRejected: function onRejected(reason) {
            return resolver.reject(rejectionTransformation(reason));
          },
          onResolved: function onResolved(value) {
            return resolver.resolve(successTransformation(value));
          }
        });
        return execution;
      }, function (execution) {
        return execution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e1, e2, v1, v2, r:
     *     type Pattern = { row |
     *       Cancelled: ()  => Task e2 v2 r,
     *       Resolved:  (b) => Task e2 v2 r,
     *       Rejected:  (a) => Task e2 v2 r
     *     }
     *
     *     (Task e1 v1 r).(Pattern) => Task e2 v2 r
     */

  }, {
    key: 'willMatchWith',
    value: function willMatchWith(pattern) {
      var _this5 = this;

      return new Task(function (resolver) {
        var execution = _this5.run();
        var resolve = function resolve(handler) {
          return function (value) {
            return handler(value).run().listen({
              onCancelled: resolver.cancel,
              onRejected: resolver.reject,
              onResolved: resolver.resolve
            });
          };
        };
        execution.listen({
          onCancelled: resolve(function (_) {
            return pattern.Cancelled();
          }),
          onRejected: resolve(pattern.Rejected),
          onResolved: resolve(pattern.Resolved)
        });
        return execution;
      }, function (execution) {
        return execution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e, v, r: (Task e v r).() => Task v e r
     */

  }, {
    key: 'swap',
    value: function swap() {
      var _this6 = this;

      return new Task(function (resolver) {
        var execution = _this6.run(); // eslint-disable-line prefer-const
        execution.listen({
          onCancelled: resolver.cancel,
          onRejected: resolver.resolve,
          onResolved: resolver.reject
        });
        return execution;
      }, function (execution) {
        return execution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e, e2, v, r1, r2:
     *     (Task e v r1).((e) => Task e2 v r2) => Task e2 v r2
     */

  }, {
    key: 'orElse',
    value: function orElse(handler) {
      var _this7 = this;

      return new Task(function (resolver) {
        var execution = _this7.run();
        execution.listen({
          onCancelled: resolver.cancel,
          onResolved: resolver.resolve,
          onRejected: function onRejected(reason) {
            handler(reason).run().listen({
              onCancelled: resolver.cancel,
              onRejected: resolver.reject,
              onResolved: resolver.resolve
            });
          }
        });
        return execution;
      }, function (execution) {
        return execution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e, v, r1, r2:
     *     (Task e v r1).(Task e v r2) => Task e v (r1 and r2)
     */

  }, {
    key: 'or',
    value: function or(that) {
      var _this8 = this;

      return new Task(function (resolver) {
        var thisExecution = _this8.run(); // eslint-disable-line prefer-const
        var thatExecution = that.run(); // eslint-disable-line prefer-const
        var done = false;

        var guard = function guard(fn, execution) {
          return function (value) {
            if (!done) {
              done = true;
              execution.cancel();
              fn(value);
            }
          };
        };

        thisExecution.listen({
          onRejected: guard(resolver.reject, thatExecution),
          onCancelled: guard(resolver.cancel, thatExecution),
          onResolved: guard(resolver.resolve, thatExecution)
        });

        thatExecution.listen({
          onRejected: guard(resolver.reject, thisExecution),
          onCancelled: guard(resolver.cancel, thisExecution),
          onResolved: guard(resolver.resolve, thisExecution)
        });

        return [thisExecution, thatExecution];
      }, function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            thisExecution = _ref2[0],
            thatExecution = _ref2[1];

        thisExecution.cancel();
        thatExecution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e, v1, v2, r1, r2:
     *     (Task e v1 r1).(Task e v2 r2) => Task e (v1, v2) (r1 and r2)
     */

  }, {
    key: 'and',
    value: function and(that) {
      var _this9 = this;

      return new Task(function (resolver) {
        // eslint-disable-line max-statements
        var thisExecution = _this9.run(); // eslint-disable-line prefer-const
        var thatExecution = that.run(); // eslint-disable-line prefer-const
        var valueLeft = null;
        var valueRight = null;
        var doneLeft = false;
        var doneRight = false;
        var cancelled = false;

        var guardResolve = function guardResolve(setter) {
          return function (value) {
            if (cancelled) return;

            setter(value);
            if (doneLeft && doneRight) {
              resolver.resolve([valueLeft, valueRight]);
            }
          };
        };

        var guardRejection = function guardRejection(fn, execution) {
          return function (value) {
            if (cancelled) return;

            cancelled = true;
            execution.cancel();
            fn(value);
          };
        };

        thisExecution.listen({
          onRejected: guardRejection(resolver.reject, thatExecution),
          onCancelled: guardRejection(resolver.cancel, thatExecution),
          onResolved: guardResolve(function (x) {
            valueLeft = x;
            doneLeft = true;
          })
        });

        thatExecution.listen({
          onRejected: guardRejection(resolver.reject, thisExecution),
          onCancelled: guardRejection(resolver.cancel, thisExecution),
          onResolved: guardResolve(function (x) {
            valueRight = x;
            doneRight = true;
          })
        });

        return [thisExecution, thatExecution];
      }, function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            thisExecution = _ref4[0],
            thatExecution = _ref4[1];

        thisExecution.cancel();
        thatExecution.cancel();
      });
    }

    /*~
     * stability: experimental
     * type: |
     *   forall e, v, r: (Task e v r).() => TaskExecution e v r
     */

  }, {
    key: 'run',
    value: function run() {
      var _this10 = this;

      var deferred = new Deferred(); // eslint-disable-line prefer-const
      deferred.listen({
        onCancelled: function onCancelled(_) {
          defer(function (_) {
            _this10._onCancel(resources);
            _this10._cleanup(resources);
          });
        },

        onResolved: function onResolved(_value) {
          defer(function (_) {
            _this10._cleanup(resources);
          });
        },

        onRejected: function onRejected(_reason) {
          defer(function (_) {
            _this10._cleanup(resources);
          });
        }
      });

      var resources = this._computation({
        reject: function reject(error) {
          deferred.reject(error);
        },
        resolve: function resolve(value) {
          deferred.resolve(value);
        },
        cancel: function cancel(_) {
          deferred.maybeCancel();
        }
      });

      return new TaskExecution(this, deferred);
    }
  }]);

  return Task;
}();

Object.assign(Task, {
  /*~
   * stability: experimental
   * type: |
   *   forall e, v, r: (v) => Task e v r
   */
  of: function of(value) {
    return new Task(function (resolver) {
      return resolver.resolve(value);
    });
  },


  /*~
   * stability: experimental
   * type: |
   *   forall e, v, r: (e) => Task e v r
   */
  rejected: function rejected(reason) {
    return new Task(function (resolver) {
      return resolver.reject(reason);
    });
  }
});

provideAliases(Task);
provideAliases(Task.prototype);

module.exports = Task;